% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cutf2.R
\name{cutf2}
\alias{cutf2}
\title{Cut a Numeric Variable into Intervals}
\usage{
cutf2(x, cuts, m = 150, g, levels.mean = FALSE, digits,
  minmax = TRUE, oneval = TRUE, onlycuts = FALSE,
  format_fun = format, ...)
}
\arguments{
\item{x}{numeric vector to classify into intervals}

\item{cuts}{cut points}

\item{m}{desired minimum number of observations in a group. The algorithm
does not guarantee that all groups will have at least m observations.}

\item{g}{number of quantile groups}

\item{levels.mean}{set to TRUE to make the new categorical vector have levels
attribute that is the group means of x instead of interval endpoint labels}

\item{digits}{number of significant digits to use in constructing levels.
Default is 3 (5 if \code{levels.mean=TRUE})}

\item{minmax}{if cuts is specified but \code{min(x)<min(cuts)} or
\code{max(x)>max(cuts)}, augments cuts to include min and max x}

\item{oneval}{if an interval contains only one unique value, the interval
will be labeled with the formatted version of that value instead of the
interval endpoints, \code{unless oneval=FALSE}}

\item{onlycuts}{set to \code{TRUE} to only return the vector of computed cuts. This consists of the interior values plus outer ranges.}

\item{format_fun}{formatting function}

\item{...}{additional arguments passed to \code{format_fun}}
}
\value{
a factor variable with levels of the form \code{[a,b)} or formatted means
(character strings) unless \code{onlycuts} is \code{TRUE} in which case a numeric
vector is returned
}
\description{
This is a copy of Frank Harell's \code{Hmisc::cut2} function which uses the
additional parameters \code{format_fun} and \code{...} to apply custom formatting to
the input. By default it behaves exactly like \code{Hmisc::cut2}
}
\examples{
set.seed(1)
Z <- 1000*stats::rnorm(10000)
table(cutf2(Z, c(-10005, -5000, 100, 0, 50, 10000)))
table(cutf2(Z, c(-10005, -5000, 100, 0, 50, 10000), format_fun = formatC))
table(cutf2(Z, c(-10005, -5000, 100, 0, 50, 10000), format_fun = signif2)) # investigate NaN issue!
table(cutf2(Z, c(-10005, -5000, 100, 0, 50, 10000), format_fun = format_metric))
table(cutf2(Z, g=10))      # quantile groups
table(cutf2(Z, g=10, format_fun = formatC))
table(cutf2(Z, g=10, format_fun = signif2))
table(cutf2(Z, g=10, format_fun = format_metric))
table(cutf2(Z, m=500))      # group x into intevals with at least 50 obs.
table(cutf2(Z, m=500, format_fun = formatC))
table(cutf2(Z, m=500, format_fun = signif2))
table(cutf2(Z, m=500, format_fun = format_metric))
}
